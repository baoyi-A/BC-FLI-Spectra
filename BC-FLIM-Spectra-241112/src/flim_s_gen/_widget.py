"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

import os
import pickle
import sys

import cv2
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QFont
from matplotlib import pyplot as plt
from napari.utils import Colormap, notifications
from scipy.optimize import curve_fit
from scipy.spatial import distance
from scipy.spatial.distance import cdist
from shapely import Point
import napari
from magicgui import widgets
import tifffile as tiff
from typing import TYPE_CHECKING

import pandas as pd
from magicgui import magic_factory
from magicgui.widgets import Container, FloatSpinBox
from qtpy.QtWidgets import QWidget
import scipy.ndimage as ndi
from skimage import measure
from skimage.draw import polygon
from skimage.measure import regionprops, label
from tqdm import tqdm

import tkinter as tk
from tkinter import messagebox


def exp_func(x, a, tau, c):
    return a * np.exp(-x / tau ) + c

def calcu_phasor_info(roi_decay_data,  peak_idx, tau_resolution=0.1, pulse_freq=80, harmonics=1, PEAK_OFFSET=0, END_OFFSET=0):
    # That's the wierd peak for Leica FALCON, not tunable parameter!
    peak2_begin = 77
    peak2_end = 84

    # Create a mask to select desired part of decay curve
    mask_start = peak_idx + PEAK_OFFSET
    mask_end = len(roi_decay_data) - END_OFFSET

    decay_segment_mask = np.zeros_like(roi_decay_data, dtype=bool)
    decay_segment_mask[mask_start:mask_end] = True

    # Use the mask to get the segment of the decay curve
    roi_decay_data_segment = roi_decay_data[decay_segment_mask]
    # Normalize the decay segment with the peak value
    roi_decay_data_normalized = roi_decay_data_segment / np.max(roi_decay_data_segment)

    # Fit the decay curve to an exponential function
    t_arr = np.arange(len(roi_decay_data_normalized)) * tau_resolution

    roi_decay_data_normalized = np.delete(roi_decay_data_normalized,
                                          np.arange(peak2_begin - mask_start, peak2_end - mask_start))
    t_arr = np.delete(t_arr, np.arange(peak2_begin - mask_start, peak2_end - mask_start))

    # fastflim calculation
    fastflim = np.sum(roi_decay_data_normalized * t_arr) / np.sum(roi_decay_data_normalized)

    params_init = [1, 2, 0]
    popt, pcov = curve_fit(exp_func, t_arr, roi_decay_data_normalized, p0=params_init)
    # get the lifetime and 卡方值
    lifetime = popt[1]
    chi_square = np.sum((roi_decay_data_normalized - exp_func(t_arr, *popt)) ** 2)
    pulse_freq = pulse_freq / 1000 # MHz to GHz
    # Computing g and s coordinates freq: 80MHz, tau_res: 10^9 times, so 1/1000
    phasor_g = np.sum(roi_decay_data_normalized * np.cos(2 * np.pi * pulse_freq * harmonics * t_arr)) / np.sum(
        roi_decay_data_normalized)
    phasor_s = np.sum(roi_decay_data_normalized * np.sin(2 * np.pi * pulse_freq * harmonics * t_arr)) / np.sum(
        roi_decay_data_normalized)

    print(f'g: {phasor_g}, s: {phasor_s}')
    return phasor_g, phasor_s, lifetime, chi_square, fastflim

# Parameter input: mask intensity threshold, pixel intensity threshold, peak offset, end offset, tau resolution, pulse frequency, harmonics, pixel_wise

def Gen_excel(stack1, stack2, stack3, stack4, output_folder, seg_img, mask_int_thres, pixel_int_thres,
              peak_offset, end_offset, tau_resolution, pulse_freq, harmonics, pixel_wise):
    # stack1-4 are tiff stacks, no need to read them
    if pixel_wise:
        save_path = os.path.join(output_folder, 'FLIM-S_pixel.xlsx')
        print('Pixel-wise mode is not supported currently.')
    else:
        save_path = os.path.join(output_folder, 'FLIM-S.xlsx')

    phasor_g_values = []
    phasor_s_values = []
    lifetime_values = []
    chi_square_values = []
    total_intensity_values = []
    mask_labels = []
    fastflim_values = []
    int_570_590_values = []
    int_590_610_values = []
    int_610_638_values = []
    int_638_720_values = []
    norm_1_4_1_values = []  # 1-4 channels normalization
    norm_1_4_2_values = []
    norm_1_4_3_values = []
    norm_1_4_4_values = []

    labels = np.unique(seg_img)
    labels = labels[labels != 0]  # Exclude the background label

    # sum the stack along the time axis to get the intensity image
    intensity_1 = np.sum(stack1, axis=0)
    intensity_2 = np.sum(stack2, axis=0)
    intensity_3 = np.sum(stack3, axis=0)
    intensity_4 = np.sum(stack4, axis=0)
    intensity_image = intensity_1 + intensity_2 + intensity_3 + intensity_4

    # decay data is the sum of the stacks
    decay_data = stack1 + stack2 + stack3 + stack4

    for label in labels:
        cell_mask = seg_img == label
        valid_pixel_mask = (intensity_image >= pixel_int_thres) & cell_mask
        mask_intensity = np.sum(intensity_image[cell_mask])
        if mask_intensity < mask_int_thres:
            print(f"Mask with label {label} excluded due to low total intensity.")
            continue
        roi_decay_data = np.sum(decay_data[:, valid_pixel_mask], axis=-1)
        peak_idx = np.argmax(roi_decay_data)
        total_intensity = np.sum(intensity_image[cell_mask])
        phasor_g, phasor_s, lifetime, chi_square, fastflim = \
            calcu_phasor_info(roi_decay_data, peak_idx=peak_idx, PEAK_OFFSET=peak_offset, END_OFFSET=end_offset,
                              tau_resolution=tau_resolution, pulse_freq=pulse_freq, harmonics=harmonics)
        int_570_590 = np.sum(intensity_1[cell_mask])
        int_590_610 = np.sum(intensity_2[cell_mask])
        int_610_638 = np.sum(intensity_3[cell_mask])
        int_638_720 = np.sum(intensity_4[cell_mask])
        norm_1_4_1 = int_570_590 / total_intensity
        norm_1_4_2 = int_590_610 / total_intensity
        norm_1_4_3 = int_610_638 / total_intensity
        norm_1_4_4 = int_638_720 / total_intensity

        phasor_g_values.append(phasor_g)
        phasor_s_values.append(phasor_s)
        lifetime_values.append(lifetime)
        chi_square_values.append(chi_square)
        total_intensity_values.append(total_intensity)
        mask_labels.append(label)
        fastflim_values.append(fastflim)
        int_570_590_values.append(int_570_590)
        int_590_610_values.append(int_590_610)
        int_610_638_values.append(int_610_638)
        int_638_720_values.append(int_638_720)
        norm_1_4_1_values.append(norm_1_4_1)
        norm_1_4_2_values.append(norm_1_4_2)
        norm_1_4_3_values.append(norm_1_4_3)
        norm_1_4_4_values.append(norm_1_4_4)

    phasor_g_values = np.array(phasor_g_values)
    phasor_s_values = np.array(phasor_s_values)
    lifetime_values = np.array(lifetime_values)
    chi_square_values = np.array(chi_square_values)
    total_intensity_values = np.array(total_intensity_values)
    mask_labels = np.array(mask_labels)
    fastflim_values = np.array(fastflim_values)
    int_570_590_values = np.array(int_570_590_values)
    int_590_610_values = np.array(int_590_610_values)
    int_610_638_values = np.array(int_610_638_values)
    int_638_720_values = np.array(int_638_720_values)
    norm_1_4_1_values = np.array(norm_1_4_1_values)
    norm_1_4_2_values = np.array(norm_1_4_2_values)
    norm_1_4_3_values = np.array(norm_1_4_3_values)
    norm_1_4_4_values = np.array(norm_1_4_4_values)

    data_df = pd.DataFrame({
        'G': phasor_g_values,
        'S': phasor_s_values,
        'Lifetime': lifetime_values,
        'Chi^2': chi_square_values,
        'Total intensity': total_intensity_values,
        'Mask label': mask_labels,
        'FastFLIM': fastflim_values,
        'Int 570-590': int_570_590_values,
        'Int 590-610': int_590_610_values,
        'Int 610-638': int_610_638_values,
        'Int 638-720': int_638_720_values,
        'Int 1/(1-4)': norm_1_4_1_values,
        'Int 2/(1-4)': norm_1_4_2_values,
        'Int 3/(1-4)': norm_1_4_3_values,
        'Int 4/(1-4)': norm_1_4_4_values,
    })

    if os.path.exists(save_path):
        print('Excel file already exists, will overwrite the data.')

    data_df.to_excel(save_path, index=False)
    print(f'Excel file saved at {save_path}')

    return data_df

def get_color_map(n_colors):
    color_list_14 = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#469990', '#9A6324', '#808000', '#000075', '#800000', '#aaffc3']
    colors = color_list_14[:n_colors]
    return colors







# import seg2flim_s

if TYPE_CHECKING:
    import napari


# Uses the `autogenerate: true` flag in the plugin manifest
# to indicate it should be wrapped as a magicgui to autogenerate
# a widget.
def threshold_autogenerate_widget(
    img: "napari.types.ImageData",
    threshold: "float",
) -> "napari.types.LabelsData":
    return img_as_float(img) > threshold


# the magic_factory decorator lets us customize aspects of our widget
# we specify a widget type for the threshold parameter
# and use auto_call=True so the function is called whenever
# the value of a parameter changes
@magic_factory(
    threshold={"widget_type": "FloatSlider", "max": 1}, auto_call=True
)
def threshold_magic_widget(
    img_layer: "napari.layers.Image", threshold: "float"
) -> "napari.types.LabelsData":
    return img_as_float(img_layer.data) > threshold


# if we want even more control over our widget, we can use
# magicgui `Container`
class ImageThreshold(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self._viewer = viewer
        # use create_widget to generate widgets from type annotations
        self._image_layer_combo = create_widget(
            label="Image", annotation="napari.layers.Image"
        )
        self._threshold_slider = create_widget(
            label="Threshold", annotation=float, widget_type="FloatSlider"
        )
        self._threshold_slider.min = 0
        self._threshold_slider.max = 1
        # use magicgui widgets directly
        self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

        # connect your own callbacks
        self._threshold_slider.changed.connect(self._threshold_im)
        self._invert_checkbox.changed.connect(self._threshold_im)

        # append into/extend the container with your widgets
        self.extend(
            [
                self._image_layer_combo,
                self._threshold_slider,
                self._invert_checkbox,
            ]
        )

    def _threshold_im(self):
        image_layer = self._image_layer_combo.value
        if image_layer is None:
            return

        image = img_as_float(image_layer.data)
        name = image_layer.name + "_thresholded"
        threshold = self._threshold_slider.value
        if self._invert_checkbox.value:
            thresholded = image < threshold
        else:
            thresholded = image > threshold
        if name in self._viewer.layers:
            self._viewer.layers[name].data = thresholded
        else:
            self._viewer.add_labels(thresholded, name=name)


class ExampleQWidget(QWidget):
    # your QWidget.__init__ can optionally request the napari viewer instance
    # use a type annotation of 'napari.viewer.Viewer' for any parameter
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer

        btn = QPushButton("Click me!")
        btn.clicked.connect(self._on_click)

        self.setLayout(QHBoxLayout())
        self.layout().addWidget(btn)

    def _on_click(self):
        print("napari has", len(self.viewer.layers), "layers")




from qtpy.QtWidgets import QWidget, QVBoxLayout
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

class PlotWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.figure = Figure(figsize=(10, 2.5))
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        self.layout = QVBoxLayout()
        self.layout.addWidget(self.toolbar)
        self.layout.addWidget(self.canvas)
        self.setLayout(self.layout)

    def plot_phasor(self, g_values, s_values):
        # self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.scatter(g_values, s_values)
        # Draw a semi-circle for reference
        theta = np.linspace(0, np.pi, 100)
        x = 0.5 + 0.5 * np.cos(theta)
        y = 0.5 * np.sin(theta)
        ax.plot(x, y)
        ax.set_xlabel('G')
        ax.set_ylabel('S')
        ax.set_title('Phasor plot')
        self.canvas.draw()

    def plot_UMAP(self, colors, hulls, umap_transformed, df, checked_classes):
        # self.setFixedSize(QSize(3000, 500))

        colors = [(int(c[1:3], 16), int(c[3:5], 16), int(c[5:7], 16)) for c in colors]
        colors = [(r / 255, g / 255, b / 255) for r, g, b in colors]
        # ax = self.figure.add_subplot(141)
        ax = self.figure.add_subplot(131)
        self.figure.set_size_inches(7,7)  # set figure size

        for i, (polygon, _) in enumerate(hulls):  # Unpack the tuple into a polygon and ignore the second value
            # if not in check_classes, continue
            if i not in checked_classes:
                continue
            x, y = polygon.exterior.xy
            ax.plot(x, y, color=colors[i], alpha=0.5)

            for j, point in enumerate(umap_transformed):
                point_geometry = Point(point)
                if polygon.contains(point_geometry):
                    ax.scatter(point[0], point[1], color=colors[i])
                    # append the class to the df, get the jth row(excluding the header), and set the class to i
                    df.loc[j, 'class'] = i
        # color the unclassified points black
        for j, point in enumerate(umap_transformed):
            if df.loc[j, 'class'] == -1:
                ax.scatter(point[0], point[1], color='black', alpha=0.5)
        ax.set_xlabel('UMAP 1')
        ax.set_ylabel('UMAP 2')
        ax.set_title('UMAP Projection')

        self.canvas.draw()

    def plot_phasor_cls(self, g_values, s_values, class_values, colors, checked_cls):
        # self.figure.clear()
        # ax = self.figure.add_subplot(142)
        ax = self.figure.add_subplot(132)
        # set figure size
        self.figure.set_size_inches(7,7)
        for i, color in enumerate(colors):
            if i not in checked_cls:
                continue
            idx = class_values == i
            ax.scatter(g_values[idx], s_values[idx], color=color, label=f'Class {i}')
        ax.set_xlabel('G')
        ax.set_ylabel('S')
        ax.set_title('Phasor plot')
        self.canvas.draw()

    def plot_int12_cls(self, int1, int2, class_values, colors, checked_cls):
        # self.figure.clear()
        ax = self.figure.add_subplot(143)
        # set figure size
        self.figure.set_size_inches(7,7)
        for i, color in enumerate(colors):
            if i not in checked_cls:
                continue
            idx = class_values == i
            ax.scatter(int1[idx], int2[idx], color=color, label=f'Class {i}')
        ax.set_xlabel('Int 1')
        ax.set_ylabel('Int 2')
        ax.set_title('Int 1-2 plot')
        self.canvas.draw()

    def plot_int13_cls(self, int1, int3, class_values, colors, checked_cls):
        # self.figure.clear()
        ax = self.figure.add_subplot(144)
        # set figure size
        self.figure.set_size_inches(7,7)
        for i, color in enumerate(colors):
            if i not in checked_cls:
                continue
            idx = class_values == i
            ax.scatter(int1[idx], int3[idx], color=color, label=f'Class {i}')
        ax.set_xlabel('Int 1')
        ax.set_ylabel('Int 3')
        ax.set_title('Int 1-3 plot')
        self.canvas.draw()

    def plot_int123_cls(self, int1, int2, int3, class_values, colors, checked_cls):
        # self.figure.clear()
        ax = self.figure.add_subplot(133)
        self.figure.set_size_inches(10, 7)  # Adjust the size as necessary
        marker_styles = ['o', '*']

        for i, color in enumerate(colors):
            if i not in checked_cls:
                continue

            # Indices where the class matches
            idx = class_values == i

            # Plot int2 with the first marker style
            ax.scatter(int1[idx], int2[idx], color=color, marker=marker_styles[0], label=f'Class {i} int2')

            # Plot int3 with the second marker style
            ax.scatter(int1[idx], int3[idx], color=color, marker=marker_styles[1], label=f'Class {i} int3')

        ax.set_xlabel('Int 1')
        ax.set_ylabel('Int 2(o) & Int 3(*)')
        ax.set_title('Spectral Intensity Plot')
        # ax.legend()
        self.canvas.draw()

    def plot_signal(self, sum_b, sum_g, ratio_gb):
        # Clear the current figure
        self.figure.clear()
        # print('Plotting signal')
        # Create three subplots
        ax1 = self.figure.add_subplot(1, 3, 1)
        ax2 = self.figure.add_subplot(1, 3, 2)
        ax3 = self.figure.add_subplot(1, 3, 3)

        # Plot sum_b, sum_g, and ratio_gb on the three subplots
        ax1.plot(sum_b, color='blue')
        ax1.set_title('Sum B')

        ax2.plot(sum_g, color='green')
        ax2.set_title('Sum G')

        ax3.plot(ratio_gb, color='red')
        ax3.set_title('Ratio G/B')

        # Refresh the canvas
        self.canvas.draw()

from skimage.util import img_as_float
from magicgui.widgets import Container, create_widget, CheckBox
import numpy as np

from skimage.util import img_as_float
from magicgui.widgets import Container, create_widget, FileEdit, CheckBox, PushButton, ComboBox, Label, LineEdit
import numpy as np
from qtpy.QtWidgets import QFileDialog

class PTU_reader:
    pass

class Calculate_FLIM_S(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self._viewer = viewer

        # Create widget for selecting TIFF stacks
        self._stack_selectors = [
            create_widget(label=f"Stack {i + 1}", annotation="napari.layers.Image")
            for i in range(4)
        ]

        # Widget to choose the output directory
        self._output_dir = FileEdit(label="Output Folder", mode='d')
        self._output_dir.value = ''  # Default value is the current directory

        # Widget for selecting a segmentation image
        self._segmentation_image = create_widget(label="Segmentation", annotation="napari.layers.Image")

        # Parameter input: mask intensity threshold, pixel intensity threshold, peak offset, end offset, tau resolution, pulse frequency, harmonics
        self._mask_int_thres = create_widget(label="Mask Intensity Threshold", widget_type="Slider", value=1500)
        self._mask_int_thres.min = 500
        self._mask_int_thres.max = 100000

        self._pixel_int_thres = create_widget(label="Pixel Intensity Threshold", widget_type="Slider", value=7)
        self._pixel_int_thres.min = 0
        self._pixel_int_thres.max = 500

        self._peak_offset = create_widget(label="Peak Offset(bins)", widget_type="Slider", value=4)
        self._peak_offset.min = 0
        self._peak_offset.max = 20

        self._end_offset = create_widget(label="End Offset(bins)", widget_type="Slider", value=18)
        self._end_offset.min = 0
        self._end_offset.max = 50

        self._tau_resolution = create_widget(
            label="Tau Resolution(ns)",
            widget_type=FloatSpinBox,
            value=0.097,
            options={'min': 0, 'max': 1, 'step': 0.001}  # Use options to specify min, max, step
        )

        self._pulse_frequency = create_widget(
            label="Pulse Frequency(MHz)",
            widget_type=FloatSpinBox,
            value=78.1,
            options={'min': 0, 'max': 100, 'step': 0.1}
        )

        self._harmonics = create_widget(label="Harmonics", widget_type="Slider", value=1)
        self._harmonics.min = 1
        self._harmonics.max = 10

        # add a true or fulse checkbox for pixel-wise or not
        self._pixel_wise = CheckBox(label="Pixel-wise") # there's no checked keyword argument!

        # Summation and processing button
        self._process_button = PushButton(text="Process and Save to Excel")
        self._process_button.clicked.connect(self.process_and_save_to_excel)

        # Extend the container with the new widgets and button
        self.extend(
            self._stack_selectors +
            [self._output_dir, self._segmentation_image, self._mask_int_thres, self._pulse_frequency,
             self._pixel_int_thres, self._peak_offset, self._end_offset, self._tau_resolution,
             self._harmonics, self._pixel_wise, self._process_button]
        )

        self.plot_widget = PlotWidget()
        viewer.window.add_dock_widget(self.plot_widget, area='right', name='Phasor Plot')
    def process_and_save_to_excel(self):
        # Get the data from the widgets
        stack_1 = self._stack_selectors[0].value
        stack_2 = self._stack_selectors[1].value
        stack_3 = self._stack_selectors[2].value
        stack_4 = self._stack_selectors[3].value
        output_folder = self._output_dir.value
        segmentation = self._segmentation_image.value
        mask_int_thres = self._mask_int_thres.value
        pixel_int_thres = self._pixel_int_thres.value
        peak_offset = self._peak_offset.value
        end_offset = self._end_offset.value
        tau_resolution = self._tau_resolution.value
        pulse_frequency = self._pulse_frequency.value
        harmonics = self._harmonics.value
        pixel_wise = self._pixel_wise.value

        # Placeholder for the actual implementation of data processing and Excel output
        stack_1 = stack_1.data
        stack_2 = stack_2.data
        stack_3 = stack_3.data
        stack_4 = stack_4.data
        segmentation = segmentation.data

        data_df = Gen_excel(stack_1, stack_2, stack_3, stack_4, output_folder, segmentation, mask_int_thres, pixel_int_thres,
                             peak_offset, end_offset, tau_resolution, pulse_frequency, harmonics, pixel_wise)

        # show G,S scatter plot on the right bar in napari, using matplotlib
        # plt.figure()
        # plt.scatter(data_df['G'], data_df['S'])
        # # also draw a semi-circle for reference, center = (0.5,0), r = 0.5, S > 0
        # theta = np.linspace(0, np.pi, 100)
        # x = 0.5 + 0.5 * np.cos(theta)
        # y = 0.5 * np.sin(theta)
        # plt.plot(x, y, 'r--')
        # plt.xlabel('G')
        # plt.ylabel('S')
        # plt.title('G-S plot')
        # plt.show()

        self._update_phasor_plot(data_df['G'], data_df['S'])

    def _update_phasor_plot(self, g_values, s_values):
        self.plot_widget.plot_phasor(g_values, s_values)

class FLIM_S_check():
    pass






from qtpy.QtWidgets import QWidget, QHBoxLayout, QLabel, QLineEdit, QCheckBox, QPushButton


def create_colored_checkbox(color: str, label_text: str) -> Container:
    """
    Creates a container with a colored label (simulating a colored circle) and a checkbox.

    :param color: Hex code for the color.
    :param label_text: Text for the checkbox.
    :return: A Container widget containing the colored label and checkbox.
    """
    container = Container(layout='horizontal') # layout can be 'horizontal' or 'vertical', vertical means one widget below another
    color_label = Label(value='    ')  # Using spaces to create a 'circle'
    color_label.native.setStyleSheet(f"background-color: {color}; border-radius: 10px; min-width: 20px;")
    checkbox = CheckBox(text=label_text)

    container.append(color_label)
    container.append(checkbox)

    return container

class UMAP_Class(Container):
    def __init__(self, napari_viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = napari_viewer



        # get number of classes from the user
        self.num_classes = widgets.IntSlider(value=14, min=1, max=20, step=1, label='Number of Classes')
        self.file_edit_excel = FileEdit(label="FLIM-S Excel", mode='r', filter='*.xlsx', value=r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\N1-2-3-4-7-8-9-10-11-12-13-14-15-16_Nu-FSK.xlsx')
        # self.file_edit_tif = FileEdit(label="TIF Image(single)", mode='r', filter='*.tif')
        self.file_edit_seg = FileEdit(label="Segmentation", mode='r', value=r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\intensity\60uM_forskolin-sum_cp_masks.png')
        self.file_edit_umap = FileEdit(label="UMAP Model(pre-trained)", mode='r', value=r'E:\BC-FLIM\Hek293T-BJMU\umap_model_yanhua.pkl')
        self.file_edit_hulls = FileEdit(label="Hulls in UMAP", mode='r', value=r'E:\BC-FLIM\Hek293T-BJMU\dilated_hulls_yanhua.pkl')

        self.process_button = PushButton(text="Process and Visualize")
        self.process_button.clicked.connect(self.process_and_visualize)

        self._excel_save_path = FileEdit(label="Save Excel to", mode='w', filter='*.xlsx', value=r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\N1-2-3-4-7-8-9-10-11-12-13-14-15-16_Nu-FSK_classified.xlsx')
        self._excel_save_button = PushButton(text="Save cls results")
        self._excel_save_button.clicked.connect(self.save_classified_excel)
        self.colors = get_color_map(self.num_classes.value)
        # self.labels = ['Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6',
        #                'Class 7', 'Class 8', 'Class 9', 'Class 10', 'Class 11', 'Class 12', 'Class 13', 'Class 14']
        # self.labels = [f'Class {i+1}' for i in range(self.num_classes.value)]
        self.labels = ['mScarlet3', 'mScarlet-I3', 'mScarlet-I', 'mApple', 'mRuby3', 'mKate2',
                       'FR-MQV', 'TagRFP-T','FR-MQ','FR-1', 'FR-M', 'FR', 'mCherry','mScarlet-H',]

        self.class_widgets = []
        self._update_plot_button = PushButton(text="Update Plot")
        self._update_plot_button.clicked.connect(self.update_plot)
        self.df = None
        # Extend the container with new widgets
        self.append(self.file_edit_excel)
        # self.append(self.file_edit_tif)
        self.append(self.file_edit_seg)
        self.append(self.file_edit_umap)
        self.append(self.file_edit_hulls)
        self.append(self.process_button)
        self.append(self._excel_save_path)
        self.append(self._excel_save_button)


        row = None
        for i, (color, label) in enumerate(zip(self.colors, self.labels)):
            if i % 3 == 0:  # Start a new row every 3 checkboxes
                row = Container(layout='horizontal')  # Create a new row
                self.append(row)  # Add the row to the main container

            container = create_colored_checkbox(color, label)
            row.append(container)  # Add the checkbox to the current row
            self.class_widgets.append(container)

        self.append(self._update_plot_button)

        # firstly check all the boxes, make sure all classes are shown
        for widget in self.class_widgets:
            widget[1].value = True
        self.checked_classes = [i for i, widget in enumerate(self.class_widgets) if widget[1].value]

        self.plot_widget = PlotWidget()
        self.viewer.window.add_dock_widget(self.plot_widget, area='bottom', name='Original Plots')
    def remove_class(self, container):
        self.remove(container)
        self.class_widgets.remove(container)

    def process_and_visualize(self):
        # Load the Excel file, TIF image, segmentation data, and UMAP model
        self.df = pd.read_excel(self.file_edit_excel.value)
        # tif_image = tiff.imread(self.file_edit_tif.value)
        if (str(self.file_edit_seg.value)).endswith('.npy'):
            self.segmentation_data = np.load(str(self.file_edit_seg.value), allow_pickle=True).item()['masks']
        elif (str(self.file_edit_seg.value)).endswith('.tif'):
            self.segmentation_data = tiff.imread(str(self.file_edit_seg.value))
        elif (str(self.file_edit_seg.value)).endswith('.png'):
            self.segmentation_data = cv2.imread(str(self.file_edit_seg.value), cv2.IMREAD_UNCHANGED)

        with open(self.file_edit_umap.value, 'rb') as f:
            umap_model = pickle.load(f)

        # Extract features and apply UMAP transformation
        features = self.df[['G', 'S', 'Int 1/(1-4)', 'Int 2/(1-4)', 'Int 3/(1-4)']].values
        self.umap_transformed = umap_model.transform(features)

        # add 'class' column to the df for later use
        self.df['class'] = -1 # initialize to -1, meaning not classified yet
        # get the hulls for classification
        with open(self.file_edit_hulls.value, 'rb') as f:
            self.hulls = pickle.load(f)
        # Generate and display UMAP plot in a dock widget
        # self.plot_umap()
        self.plot_widget.plot_UMAP(self.colors, self.hulls, self.umap_transformed, self.df, self.checked_classes)
        # plot phasor based on the G and S values and classification results, and checked classes
        self.plot_widget.plot_phasor_cls(self.df['G'], self.df['S'], self.df['class'], self.colors, self.checked_classes)
        # self.plot_widget.plot_int12_cls(self.df['Int 1/(1-4)'], self.df['Int 2/(1-4)'], self.df['class'], self.colors, self.checked_classes)
        # self.plot_widget.plot_int13_cls(self.df['Int 1/(1-4)'], self.df['Int 3/(1-4)'], self.df['class'], self.colors, self.checked_classes)
        self.plot_widget.plot_int123_cls(self.df['Int 1/(1-4)'], self.df['Int 2/(1-4)'], self.df['Int 3/(1-4)'], self.df['class'], self.colors, self.checked_classes)
        # classified_image = self.color_image(segmentation_data)
        # self.viewer.add_image(classified_image, name="Classified Image")

        self.timer = QTimer()
        self.current_class_index = 0
        self.timer.timeout.connect(self.update_colored_image)
        self.color_image_init()

    def save_classified_excel(self):
        self.df.to_excel(self._excel_save_path.value, index=False)
        print(f"Excel file saved to {self._excel_save_path.value}")

    # def plot_umap(self):
    #     colors = self.colors
    #     colors = [(int(c[1:3], 16), int(c[3:5], 16), int(c[5:7], 16)) for c in colors]
    #     colors = [(r / 255, g / 255, b / 255) for r, g, b in colors]
    #     # Create a Matplotlib figure and canvas
    #     fig = Figure(figsize=(10,8))
    #     canvas = FigureCanvas(fig)
    #     ax = fig.add_subplot(111) # 1 row, 1 column, 1st plot
    #     # Plot UMAP data, coloring by the point's position, if it's in the ith hull, the color is the ith color
    #     # for i, hull in enumerate(hulls):
    #     #     # draw the outline of the hull
    #     #     if isinstance(hull, MultiPolygon):
    #     #         for polygon in hull.geoms:
    #     #             x, y = polygon.exterior.coords.xy
    #     #             ax.plot(x, y, color=self.colors[i], alpha=0.5)
    #     #     else:
    #     #         x, y = hull.exterior.coords.xy
    #     #         ax.plot(x, y, color=self.colors[i], alpha=0.5)
    #     for i, (polygon, _) in enumerate(self.hulls):  # Unpack the tuple into a polygon and ignore the second value
    #         # if not in check_classes, continue
    #         if i not in self.checked_classes:
    #             continue
    #         x, y = polygon.exterior.xy
    #         ax.plot(x, y, color=colors[i], alpha=0.5)
    #
    #         for j, point in enumerate(self.umap_transformed):
    #             point_geometry = Point(point)
    #             if polygon.contains(point_geometry):
    #                 ax.scatter(point[0], point[1], color=colors[i])
    #                 # append the class to the df, get the jth row(excluding the header), and set the class to i
    #                 self.df.loc[j, 'class'] = i
    #     # color the unclassified points black
    #     for j, point in enumerate(self.umap_transformed):
    #         if self.df.loc[j, 'class'] == -1:
    #             ax.scatter(point[0], point[1], color='black', alpha=0.5)
    #     ax.set_xlabel('UMAP 1')
    #     ax.set_ylabel('UMAP 2')
    #     ax.set_title('UMAP Projection')
    #
    #     # Add the canvas to the viewer as a dock widget
    #     # self.viewer.window.add_dock_widget(canvas, name="UMAP Plot", area='right')
    #     # the area can be 'left', 'right', 'top', 'bottom'
    #     self.viewer.window.add_dock_widget(canvas, name="UMAP Plot", area='bottom')

    # def color_image_init(self):
    #     colors = self.colors
    #     colors = [(int(c[1:3], 16), int(c[3:5], 16), int(c[5:7], 16)) for c in colors]
    #
    #     # Create a new image with the same shape as the input image
    #     colored_image = np.zeros(self.segmentation_data.shape + (3,), dtype=np.uint8)
    #
    #     # each time add a new calss. first time, only class 1, second, class 2, and so on, show an animation
    #     for i in range(1, len(self.labels)+1):
    #         # remove the previous classified image
    #         self.viewer.layers.select_all()
    #         self.viewer.layers.remove_selected()
    #         for j, label in enumerate(self.df['class'].unique()):
    #             if label == -1 or label not in self.checked_classes:
    #                 continue
    #             for k, mask_label in enumerate(self.df['Mask label']):
    #                 if self.df.loc[k, 'class'] == label and mask_label != 0:
    #                     colored_image[self.segmentation_data == mask_label] = colors[label]
    #         self.viewer.add_image(colored_image, name="Classified Image")
    #         # wait for 1 second
    #         time.sleep(1)

    def color_image_init(self):
        # Your existing setup code
        self.colored_image = np.zeros(self.segmentation_data.shape + (3,), dtype=np.uint8)
        # Start the timer with a 1000ms (1 second) interval
        self.timer.start(1000)

    def update_colored_image(self):
        # Check if we've added all classes
        if self.current_class_index >= self.num_classes.value:
            self.timer.stop()
            return

        # Remove the previous image and add the updated one
        if "Classified Image" in self.viewer.layers:
            self.viewer.layers.remove("Classified Image")
        # Assuming self.labels is sorted or otherwise arranged as needed
        # Update colored_image with the current class
        # Similar to your existing loop, but only for the current class
        # check classes now = 0-current_class_index
        self.checked_classes = list(range(self.current_class_index + 1))
        self.color_image()
        # Increment current_class_index for the next call
        self.current_class_index += 1





    def color_image(self):
        colors = self.colors
        colors = [(int(c[1:3], 16), int(c[3:5], 16), int(c[5:7], 16)) for c in colors]

        # Create a new image with the same shape as the input image
        colored_image = np.zeros(self.segmentation_data.shape + (3,), dtype=np.uint8)

        # For each mask_label, color the corresponding region in the image with its class
        for i, label in enumerate(self.df['class'].unique()):
            if label == -1 or label not in self.checked_classes:
                continue
            for j, mask_label in enumerate(self.df['Mask label']):
                if self.df.loc[j, 'class'] == label and mask_label != 0:
                    colored_image[self.segmentation_data == mask_label] = colors[label]
        self.viewer.add_image(colored_image, name="Classified Image")



    def update_plot(self):
        # firstly, remove the previous classified image
        self.viewer.layers.select_all()
        self.viewer.layers.remove_selected()
        # remove the previous original plots
        self.viewer.window.remove_dock_widget(self.viewer.window._dock_widgets['Original Plots'])
        # self.viewer.window.remove_dock_widget(self.viewer.window._dock_widgets['Phasor Plot'])
        # Get the checked classes
        self.checked_classes = [i for i, widget in enumerate(self.class_widgets) if widget[1].value]
        self.color_image()
        # Update the phasor, UMAP plot and the classified image
        # self.plot_umap()
        self.viewer.window.add_dock_widget(self.plot_widget, area='bottom', name='Original Plots')
        self.plot_widget.plot_UMAP(self.colors, self.hulls, self.umap_transformed, self.df, self.checked_classes)
        self.plot_widget.plot_phasor_cls(self.df['G'], self.df['S'], self.df['class'], self.colors, self.checked_classes)
        self.plot_widget.plot_int12_cls(self.df['Int 1/(1-4)'], self.df['Int 2/(1-4)'], self.df['class'], self.colors, self.checked_classes)
        self.plot_widget.plot_int13_cls(self.df['Int 1/(1-4)'], self.df['Int 3/(1-4)'], self.df['class'], self.colors, self.checked_classes)






from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans





class KMeansCluster(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer
        self.df_test = None
        self.df_test_filtered = None
        self.dims_use = ['G', 'S', 'Int 1/(1-4)', 'Int 2/(1-4)', 'Int 3/(1-4)', 'Total intensity','Mask label']
        self.dims_5D = ['G', 'S', 'Int 1/(1-4)', 'Int 2/(1-4)', 'Int 3/(1-4)']
        # self.dims_phasor = ['G', 'S']
        self.dims_phasor = ['S', 'G']
        self.dims_int123 = ['Int 1/(1-4)', 'Int 2/(1-4)', 'Int 3/(1-4)']
        self.dims_int12 = ['Int 1/(1-4)', 'Int 2/(1-4)']
        self.dims_int13 = ['Int 1/(1-4)', 'Int 3/(1-4)']
        # self.load_data()
        # load data from the excel file user selected
        self.excel_input = FileEdit(label="FLIM-S Excel", mode='r', filter='*.xlsx')
        self.excel_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\N1-2-3-4-7-8-9-10-11-12-13-14-15-16_Nu-FSK.xlsx'
        self.load_data_button = PushButton(text="Load Data")
        self.load_data_button.clicked.connect(self.load_data)
        # set intensity threshold spin box, from 0-1e6
        self.intensity_threshold = create_widget(label="Intensity Threshold", widget_type="SpinBox", value=200000, options={'min': 0, 'max': 1000000})
        # connect the intensity threshold to the update plot function
        self.intensity_threshold.changed.connect(self.update_filter)
        # spin box for number of clusters from 1-20
        self.num_clusters_input = create_widget(label="Number of Clusters", widget_type="SpinBox", value=14, options={'min': 1, 'max': 20})
        self.select_seeds_button = PushButton(text="Select Seeds")
        self.select_seeds_button.clicked.connect(self.select_seeds)
        self.run_button = PushButton(text="Run K-Means")
        self.run_button.clicked.connect(self.run_k_means)
        self.save_excel_button = PushButton(text="Export Results to Excel")
        self.save_excel_button.clicked.connect(self.export_results)

        # self.append(self.num_clusters_input)
        # self.append(self.select_seeds_button)
        # self.append(self.run_button)
        self.extend([self.excel_input, self.load_data_button, self.intensity_threshold,
                     self.num_clusters_input, self.select_seeds_button, self.run_button,
                     self.save_excel_button])
        # Setup a points layer for seed selection
        self.seed_layer = self.viewer.add_points(name='Seeds', size=10, face_color='red')

    def load_data(self):
        # Load data from Excel
        filepath = self.excel_input.value
        self.df_test = pd.read_excel(filepath, usecols=self.dims_use)
        self.df_test = self.df_test.dropna()
        self.df_test_filtered = self.df_test[self.df_test['Total intensity'] > self.intensity_threshold.value]
        # Convert DataFrame slices to NumPy arrays
        # phasor_points = self.df_test_filtered[self.dims_phasor].to_numpy()
        # int12_points = self.df_test_filtered[self.dims_int12].to_numpy()
        # int13_points = self.df_test_filtered[self.dims_int13].to_numpy()
        # make S to negative, so that the phasor plot is correct
        # phasor_points[:, 0] = -phasor_points[:, 0] # 0 means the first column S
        self.df_test_filtered['S'] = -self.df_test_filtered['S']
        # scale the points tomake them spread evenly on the plot, scale to 0-1(normalize)
        # phasor_points = (phasor_points - phasor_points.min(axis=0)) / (phasor_points.max(axis=0) - phasor_points.min(axis=0))
        # int12_points = (int12_points - int12_points.min(axis=0)) / (int12_points.max(axis=0) - int12_points.min(axis=0))
        # int13_points = (int13_points - int13_points.min(axis=0)) / (int13_points.max(axis=0) - int13_points.min(axis=0))
        self.df_test_filtered[self.dims_phasor] = (self.df_test_filtered[self.dims_phasor] - self.df_test_filtered[self.dims_phasor].min(axis=0)) / (self.df_test_filtered[self.dims_phasor].max(axis=0) - self.df_test_filtered[self.dims_phasor].min(axis=0))
        self.df_test_filtered[self.dims_int123] = (self.df_test_filtered[self.dims_int123] - self.df_test_filtered[self.dims_int123].min(axis=0)) / (self.df_test_filtered[self.dims_int123].max(axis=0) - self.df_test_filtered[self.dims_int123].min(axis=0))
        # x 1000 for better visualization
        mult_factor = 512
        # phasor_points *= mult_factor
        # int12_points *= mult_factor
        # int13_points *= mult_factor
        self.df_test_filtered[self.dims_5D] *= mult_factor
        # show phasor, int12, int13 separately in 3 points layers
        point_size = 5
        # self.viewer.add_points(phasor_points, name='Phasor', size=point_size, face_color='blue')
        # self.viewer.add_points(int12_points, name='Int12', size=point_size, face_color='green')
        # self.viewer.add_points(int13_points, name='Int13', size=point_size, face_color='red')
        self.viewer.add_points(self.df_test_filtered[self.dims_phasor], name='Phasor', size=point_size, face_color='blue')
        self.viewer.add_points(self.df_test_filtered[self.dims_int12], name='Int12', size=point_size, face_color='green')
        self.viewer.add_points(self.df_test_filtered[self.dims_int13], name='Int13', size=point_size, face_color='red')

        # make the int12 and 13 layers invisible
        self.viewer.layers['Int12'].visible = False
        self.viewer.layers['Int13'].visible = False
        # put the phasor mask on the top
        # self.viewer.layers['Phasor'].move_to_front()
        # self.viewer.layers['Phasor'].raise_()

    def update_filter(self):
        # update the 3 layers, phasor, int12, int13
        self.df_test_filtered = self.df_test[self.df_test['Total intensity'] > self.intensity_threshold.value]
        self.viewer.layers['Phasor'].data = self.df_test_filtered[self.dims_phasor]
        self.viewer.layers['Int12'].data = self.df_test_filtered[self.dims_int12]
        self.viewer.layers['Int13'].data = self.df_test_filtered[self.dims_int13]
        # refresh the plot
        self.viewer.layers['Phasor'].refresh()
        self.viewer.layers['Int12'].refresh()
        self.viewer.layers['Int13'].refresh()

    def select_seeds(self):
        self.seed_layer.mode = 'add'
        self.seed_layer.mouse_drag_callbacks.append(self.check_num_seeds)

    def check_num_seeds(self, layer, event):
        if len(self.seed_layer.data) == self.num_clusters_input.value:
            self.seed_layer.mode = 'pan_zoom'
            self.seed_layer.mouse_drag_callbacks.remove(self.check_num_seeds)

    def run_k_means(self):
        # Perform K-means clustering based on the selected seeds
        selected_seeds = np.array(self.seed_layer.data)
        # scaler = StandardScaler()
        # data_scaled = scaler.fit_transform(self.df_test[self.dims_5D])

        if selected_seeds.shape[0] != self.num_clusters_input.value:
            print("Please select the correct number of seeds.")
            return

        # Find the nearest data points to use as initial centroids
        initial_centroids_phasor = np.array([self.find_nearest(seed, self.df_test_filtered[self.dims_phasor]) for seed in selected_seeds])
        # get the initial centroids for 5D, use the index of the nearest phasor point to get the 5D info
        initial_centroids = np.array([self.df_test_filtered[self.dims_5D].iloc[np.where(np.all(self.df_test_filtered[self.dims_phasor] == seed, axis=1))[0][0]] for seed in initial_centroids_phasor])
        kmeans = KMeans(n_clusters=self.num_clusters_input.value, init=initial_centroids, n_init=1) # n_init is the number of times the k-means algorithm will be run with different centroid seeds
        kmeans.fit(self.df_test_filtered[self.dims_5D])

        # Update the face colors of the seeds to reflect the cluster assignments
        self.df_test_filtered['cluster'] = kmeans.labels_
        # self.seed_layer.face_color = [plt.cm.tab20(c) for c in kmeans.labels_ % 20]
        # update the phasor, int12, int13 layers with the cluster labels
        self.viewer.layers['Phasor'].face_color = [plt.cm.tab20(c) for c in kmeans.labels_ % 20]
        self.viewer.layers['Int12'].face_color = [plt.cm.tab20(c) for c in kmeans.labels_ % 20]
        self.viewer.layers['Int13'].face_color = [plt.cm.tab20(c) for c in kmeans.labels_ % 20]

    def find_nearest(self, point, data):
        # Calculate the Euclidean distance between the point and each row in the data
        distances = np.sqrt(np.sum((data - point) ** 2, axis=1))
        # Get the index of the row with the smallest distance
        nearest_index = distances.idxmin()
        # Return the row with the smallest distance
        return data.loc[nearest_index]
    def export_results(self):
        # Save the clustering results to an Excel file
        self.df_test.to_excel('cluster_results.xlsx')

class Trackrevise(Container):
    def set_widget_font_size(self, font_size: int):
        for widget in self.widgets:
            widget.native.setStyleSheet(f"font-size: {font_size}px")
    def __init__(self, viewer: "napari.viewer.Viewer"):

        # from napari.utils.theme import _themes
        # _themes['dark'].font_size = "16pt"

        super().__init__()
        self.viewer = viewer
        self.plot_widget = PlotWidget()
        # self.viewer.window.add_dock_widget(self.plot_widget, area='right', name='Signal')
        self.viewer.window.add_dock_widget(self.plot_widget, area='bottom', name='Signal')
        self.masks_layer = None
        self.masks_history = []
        # self.shapes_layer = None
        # add a button to read in all the masks or tiff stacks or classification image if the user filled in the path
        self.read_in_all_button = PushButton(text="Read in all files")
        # self.read_in_all_button.native.setStyleSheet("""
        # QPushButton {
        #             color: red;
        #             font-weight: bold;
        #             font-size: 20px;
        #         }
        # """)
        self.apply_button = PushButton(text="Apply to Following Frames")

        self.mask_folder = FileEdit(label="Mask Folder", mode='d')
        # self.mask_folder.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\Track-11-test'
        self.mask_folder.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240329-NE\Track-1-11'
        # self.outline_checkbox = CheckBox(label="Show Only Outline")
        # self.outline_checkbox.value = True
        self.mask_256_checkbox = CheckBox(label="Masks more than 255")
        self.mask_256_checkbox.value = False
        self.read_masks_button = PushButton(text="Read Masks")
        self.tif_input = FileEdit(label="TIF stack Input", mode='r', filter='*.tif')
        # self.tif_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240308-FSK\stack-b-1-11.tif'
        self.tif_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240329-NE\stack-b_denoised-1-11.tif'
        self.read_tif_button = PushButton(text="Read TIF stack")
        self.revise_mode_checkbox = CheckBox(label="Revise and Visualize Mode (press u to undo)")
        # self.revise_mode_checkbox.native.setStyleSheet("""
        # QCheckBox {
        #             color: red;
        #             font-weight: bold;
        #             font-size: 20px;
        #         }
        # """)
        self.revise_mode_checkbox.value = False
        self.save_tracking_button = PushButton(text="Save Tracking")
        self.excel_input = FileEdit(label="Excel Input", mode='r', filter='*.xlsx')
        self.tracking_image_input = FileEdit(label="First/Last Tracking Image", mode='r', filter='*.tif')
        self.resize_param = LineEdit(label="Resize Parameters")
        # self.shift_r_param = LineEdit(label="Right shift blue channel(pixel)") # should be a slider
        # make it a slider
        # self.shift_layer =
        shift_max = 20
        self.shift_r_param = create_widget(label="Right shift the current layer(pixel)", widget_type="Slider", value=0)
        self.shift_r_param.min = - shift_max
        self.shift_r_param.max = shift_max
        self.shift_r_param.step = 1
        self.shift_u_param = create_widget(label="Up shift the current layer(pixel)", widget_type="Slider", value=0)
        self.shift_u_param.min = - shift_max
        self.shift_u_param.max = shift_max
        self.shift_u_param.step = 1
        self.shift_button = PushButton(text="Shift")
        self.shift_save_button = PushButton(text="Save Shifted Tif stack")
        self.classify_button = PushButton(text="Classify Masks")
        self.stack_b_input = FileEdit(label="Stack B Input", mode='r', filter='*.tif')
        self.stack_b_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240329-NE\stack-b-1-11.tif'
        self.read_stack_b_button = PushButton(text="Read Stack B")
        self.stack_g_input = FileEdit(label="Stack G Input", mode='r', filter='*.tif')
        self.stack_g_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240329-NE\stack-g-1-11.tif'
        self.read_stack_g_button = PushButton(text="Read Stack G")
        self.overexpo_thres_param = create_widget(label="Overexposure Threshold", widget_type="SpinBox", value=65535, options={'min': 0, 'max': 65535})
        self.overexpo_vis_button = PushButton(text="Overexposure visualization")
        self.overexpo_discard_button = PushButton(text="Discard Overexposure Masks")

        self.save_button = PushButton(text="Save")

        self.classification_input = FileEdit(label="Classification Image", mode='r', filter='*.tif')
        self.classification_input.value = r'E:\BC-FLIM\Hek293T-BJMU\NLS-N1-2-3-4-7-8-9-10-11-12-13-14-15-16-240329-NE\intensity\100uM_NE-cls.tif'
        # create a spinbox for resize to 512, 1024, or 2048
        self.classification_resize = create_widget(label="Resize to", widget_type="SpinBox", value=1024, options={'min': 512, 'max': 2048})
        # create a
        # self.align_dist_thres = create_widget(label="align Distance Threshold (pixels)", widget_type="SpinBox", value=10, options={'min': 0, 'max': 30})
        self.align_thres_percent = create_widget(label="Align Threshold Percent", widget_type="SpinBox", value=10, options={'min': 0, 'max': 100})
        self.align_mask_frame = create_widget(label="Align to Frame", widget_type="SpinBox", value=0,
                                              options={'min': 0, 'max': 2000})
        # not working:
        # self.align_mask_frame.native.setStyleSheet("""
        #     QLabel {
        #         font-size: 30px;
        #     }
        # """)

        # font = QFont()
        # font.setPointSize(30)
        # label = self.overexpo_thres_param.native.findChild(QLabel)
        # if label:
        #     print('find label')
        #     label.setFont(font)

        # def apply_font_to_labels(widget, font_size):
        #     from PyQt5.QtWidgets import QLabel
        #     from PyQt5.QtGui import QFont
        #
        #     if isinstance(widget, QLabel):
        #         font = widget.font()
        #         font.setPointSize(font_size)
        #         widget.setFont(font)
        #
        #     for child in widget.children():
        #         print(child)
        #         apply_font_to_labels(child, font_size)
        #
        # # Apply to the widget
        # apply_font_to_labels(self.overexpo_thres_param.native, 30)

        self.classification_align_button = PushButton(text="Align Classification Masks")
        self.Bs2Code_save_path = None
        # create a widget for user to choose the ratio calcu from frame a to b, default is from 0-100, user can drag both end to change the range
        self.ratio_calcu_range = create_widget(label="Ratio Calculation Range", widget_type="RangeSlider", value=[0, 100], options={'min': 0, 'max': 2000})
        self.basal_frame_spinbox = create_widget(label="Basal Frame Number", widget_type="SpinBox", value=34, options={'min': 0, 'max': 2000})
        self.ratio_calcu_button = PushButton(text="Calculate Signal Ratio")

        # set the font size
        # self.widgets = [self.read_in_all_button, self.mask_folder, self.mask_256_checkbox, self.read_masks_button, self.tif_input, self.read_tif_button,
        #            self.revise_mode_checkbox, self.apply_button, self.save_tracking_button, self.stack_b_input, self.read_stack_b_button, self.stack_g_input,
        #              self.read_stack_g_button, self.overexpo_thres_param, self.overexpo_vis_button, self.overexpo_discard_button,
        #              self.shift_r_param, self.shift_u_param, self.shift_button, self.shift_save_button, self.classification_input, self.classification_resize,
        #                 self.align_thres_percent, self.align_mask_frame, self.classification_align_button, self.ratio_calcu_range, self.basal_frame_spinbox,
        #                 self.ratio_calcu_button]
        # self.set_widget_font_size(16)

        # Connect callbacks
        self.read_in_all_button.clicked.connect(self.read_in_all)
        self.read_masks_button.clicked.connect(self.read_masks)
        self.read_tif_button.clicked.connect(lambda: self.read_tif('TIF for Tracking'))
        self.read_stack_b_button.clicked.connect(lambda: self.read_tif('Stack B'))
        self.read_stack_g_button.clicked.connect(lambda: self.read_tif('Stack G'))
        self.apply_button.clicked.connect(self.apply_to_following_frames)
        self.save_tracking_button.clicked.connect(self.save_tracking)
        self.shift_button.clicked.connect(self.shift_stack) # may also need a green shift
        self.shift_save_button.clicked.connect(self.save_shifted_stack)
        self.overexpo_vis_button.clicked.connect(self.overexpo_visualize)
        self.overexpo_discard_button.clicked.connect(self.overexpo_discard)
        # self.outline_checkbox.changed.connect(self.toggle_outline)
        self.revise_mode_checkbox.changed.connect(self.toggle_revise_mode)


        self.classification_input.changed.connect(self.load_classification)
        self.classification_resize.changed.connect(self.load_classification)
        self.classification_align_button.clicked.connect(self.align_classification)
        self.ratio_calcu_button.clicked.connect(self.calculate_signal_ratio)

        # Add widgets to the container
        self.extend([
            self.read_in_all_button,
            self.mask_folder,
            # self.outline_checkbox,
            self.mask_256_checkbox,
            self.read_masks_button,
            self.tif_input,
            self.read_tif_button,
            self.revise_mode_checkbox,
            self.apply_button,
            self.save_tracking_button,
            self.stack_b_input,
            self.read_stack_b_button,
            self.stack_g_input,
            self.read_stack_g_button,
            self.overexpo_thres_param,
            self.overexpo_vis_button,
            self.overexpo_discard_button,
            self.shift_r_param,
            self.shift_u_param,
            self.shift_button,
            self.shift_save_button,
            self.classification_input,
            self.classification_resize,
            self.align_thres_percent,
            self.align_mask_frame,
            self.classification_align_button,
            self.ratio_calcu_range,
            self.basal_frame_spinbox,
            self.ratio_calcu_button,

        ])
    def read_in_all(self):
        # call all the read functions
        self.read_masks()
        self.read_tif('TIF for Tracking')
        self.read_tif('Stack B')
        self.read_tif('Stack G')
        self.load_classification()

    def calculate_signal_ratio(self):
        stack_start = self.ratio_calcu_range.value[0]
        stack_end = self.ratio_calcu_range.value[1] + 1
        basal_frame_num = self.basal_frame_spinbox.value

        # Check which stacks are available
        has_stack_b = 'Stack B' in self.viewer.layers
        has_stack_g = 'Stack G' in self.viewer.layers

        if not has_stack_b and not has_stack_g:
            notifications.show_error("Neither Stack B nor Stack G found in layers!")
            return

        if not has_stack_b or not has_stack_g:
            missing_stack = 'Stack B' if not has_stack_b else 'Stack G'
            response = self.show_warning_dialog(
                f"{missing_stack} is missing. Do you want to continue with only one channel?")
            if response == "add":
                notifications.show_info(f"Please add {missing_stack} and try again.")
                return
            elif response == "cancel":
                return

        def extract_intensity(stack, all_masks, cell_num, type='sum'):
            intensity_data = []
            for frame_number, frame in tqdm(enumerate(stack), total=len(stack)):
                current_masks = all_masks[frame_number]
                for cell_id in range(1, cell_num + 1):
                    cell_mask = (current_masks == cell_id)
                    if type == 'sum':
                        intensity = np.sum(frame[cell_mask])
                    elif type == 'mean':
                        intensity = np.mean(frame[cell_mask])
                    else:
                        continue
                    if intensity == 0:
                        notifications.show_warning(f'Frame: {frame_number}, Cell: {cell_id}, intensity = 0!')
                        continue
                    intensity_data.append({
                        "frame": frame_number,
                        "cell_id": cell_id,
                        "intensity": intensity
                    })
            return intensity_data

        all_masks = self.viewer.layers['Masks'].data[stack_start:stack_end]
        cell_num = len(np.unique(all_masks[0])) - 1
        notifications.show_info(f'Number of Cells: {cell_num} cells')

        # Load alignment info from Bs2Code Excel
        alignment_info = pd.read_excel(self.Bs2Code_save_path)
        alignment_info = alignment_info[['Tracking Mask Index', 'Class']]
        alignment_info = alignment_info.set_index('Tracking Mask Index')

        out_excel_path = os.path.join(self.base_folder, 'signal_analysis.xlsx')

        with pd.ExcelWriter(out_excel_path) as writer:
            if has_stack_b:
                blue_channel = self.viewer.layers['Stack B'].data[stack_start:stack_end]
                print('Extracting blue intensity...')
                blue_intensity = extract_intensity(blue_channel, all_masks, cell_num, type='sum')
                blue_df = pd.DataFrame(blue_intensity)
                blue_pivot = blue_df.pivot(index='cell_id', columns='frame', values='intensity')
                blue_pivot = self.add_class_info(blue_pivot, alignment_info)
                blue_pivot.sort_values(by='Class').to_excel(writer, sheet_name='Blue Channel (Original)')

                # Normalize blue channel
                baseline_blue = blue_pivot.iloc[:, 1:basal_frame_num + 1].mean(axis=1)
                normalized_blue = blue_pivot.div(baseline_blue, axis=0)
                normalized_blue = self.add_class_info(normalized_blue, alignment_info)
                normalized_blue.sort_values(by='Class').to_excel(writer, sheet_name='Blue Channel (Normalized)')

            if has_stack_g:
                green_channel = self.viewer.layers['Stack G'].data[stack_start:stack_end]
                print('Extracting green intensity...')
                green_intensity = extract_intensity(green_channel, all_masks, cell_num, type='sum')
                green_df = pd.DataFrame(green_intensity)
                green_pivot = green_df.pivot(index='cell_id', columns='frame', values='intensity')
                green_pivot = self.add_class_info(green_pivot, alignment_info)
                green_pivot.sort_values(by='Class').to_excel(writer, sheet_name='Green Channel (Original)')

                # Normalize green channel
                baseline_green = green_pivot.iloc[:, 1:basal_frame_num + 1].mean(axis=1)
                normalized_green = green_pivot.div(baseline_green, axis=0)
                normalized_green = self.add_class_info(normalized_green, alignment_info)
                normalized_green.sort_values(by='Class').to_excel(writer, sheet_name='Green Channel (Normalized)')

            if has_stack_b and has_stack_g:
                ratio_channel = np.divide(green_channel, blue_channel, out=np.zeros_like(green_channel, dtype=float),
                                          where=blue_channel != 0)
                print('Extracting ratio mean intensity...')
                ratio_mean = extract_intensity(ratio_channel, all_masks, cell_num, type='mean')
                ratio_mean_df = pd.DataFrame(ratio_mean)
                ratio_mean_pivot = ratio_mean_df.pivot(index='cell_id', columns='frame', values='intensity')
                mean_ratio_pivot = green_pivot / blue_pivot

                baseline_ratio_mean = ratio_mean_pivot.iloc[:, :basal_frame_num].mean(axis=1)
                normalized_ratio_mean_df = ratio_mean_pivot.div(baseline_ratio_mean, axis=0)
                baseline_mean_ratio = mean_ratio_pivot.iloc[:, :basal_frame_num].mean(axis=1)
                normalized_mean_ratio_df = mean_ratio_pivot.div(baseline_mean_ratio, axis=0)

                normalized_ratio_mean_df = self.add_class_info(normalized_ratio_mean_df, alignment_info)
                normalized_mean_ratio_df = self.add_class_info(normalized_mean_ratio_df, alignment_info)

                normalized_ratio_mean_df.sort_values(by='Class').to_excel(writer, sheet_name='Normalized Ratio Mean')
                normalized_mean_ratio_df.sort_values(by='Class').to_excel(writer, sheet_name='Normalized Mean Ratio')

        notifications.show_info(f'Saved signal analysis results to {out_excel_path}')

    def add_class_info(self, df, alignment_info):
        df['Class'] = df.index.map(lambda x: alignment_info.loc[x, 'Class'] if x in alignment_info.index else 0)
        cols = df.columns.tolist()
        cols = ['Class'] + [col for col in cols if col != 'Class']
        return df[cols]

    def show_warning_dialog(self, message):
        root = tk.Tk()
        root.withdraw()
        response = messagebox.askquestion("Warning", message + "\n\nDo you want to continue?",
                                          icon='warning', type='yesnocancel')
        if response == 'yes':
            return "continue"
        elif response == 'no':
            return "add"
        else:
            return "cancel"
    def load_classification(self):
        # load the tif file which is masks from 0-14, 0 for bg, 1-14 for cells in different classes
        classification_file = self.classification_input.value
        resize = self.classification_resize.value
        # if classification_file:
        if classification_file and os.path.exists(classification_file):
            masks = tiff.imread(classification_file)
            # resize masks from 2048 2048 to 1024 1024
            masks = cv2.resize(masks, (resize, resize), interpolation=cv2.INTER_NEAREST)
            self.viewer.add_labels(masks, name="Barcodes Masks classified", opacity=0.5)
        notifications.show_info(f'Loaded classification {np.max(masks)} classes, resized to {resize}x{resize}. Now you can align the classification masks to the tracking masks.')

    def align_classification(self):
        align_mask_frame = self.align_mask_frame.value
        tracking_masks = self.viewer.layers['Masks'].data
        cls_masks = self.viewer.layers['Barcodes Masks classified'].data
        print('Shape of cls_masks:', cls_masks.shape)

        # Label all regions in the classification masks to separate them
        cls_masks_labeled = label(cls_masks)

        # Create a mapping from labeled regions to original indices
        label_to_index = {}
        for region in regionprops(cls_masks_labeled):
            label_to_index[region.label] = cls_masks[region.coords[0][0], region.coords[0][1]]

        # Extract properties of the masks in the specified frame
        frame_props = regionprops(tracking_masks[align_mask_frame])

        # Create an array to store the new indices of the masks in tracking_masks
        cls_masks_aligned = np.zeros_like(tracking_masks)

        # Initialize a list to store alignment information for Excel
        alignment_info = []

        # Define the threshold level for considering a class in a mask
        threshold_level = self.align_thres_percent.value / 100

        # Loop over each mask in the tracking frame, use tqdm
        # for frame_mask_id, frame_prop in enumerate(frame_props, start=1):

        for frame_prop in tqdm(frame_props, desc='Aligning Classification Masks'):
            frame_mask_id = frame_prop.label
            current_mask = tracking_masks[align_mask_frame] == frame_mask_id
            overlapping_classes, counts = np.unique(cls_masks[current_mask], return_counts=True)

            # Remove the background class (0) if it exists
            if 0 in overlapping_classes:
                zero_index = np.where(overlapping_classes == 0)
                overlapping_classes = np.delete(overlapping_classes, zero_index)
                counts = np.delete(counts, zero_index)

            if len(overlapping_classes) == 0:
                nearest_cls_id = 0  # No overlapping class
            else:
                total_pixels = np.sum(current_mask)
                class_percentages = counts / total_pixels

                # Find classes that meet the threshold level
                valid_classes = overlapping_classes[class_percentages >= threshold_level]

                if len(valid_classes) == 0:
                    nearest_cls_id = 0  # No class meets the threshold
                else:
                    # Determine the class with the highest count (majority)
                    majority_class_index = np.argmax(class_percentages)
                    nearest_cls_id = overlapping_classes[majority_class_index]

            # Save alignment info
            alignment_info.append((frame_mask_id, nearest_cls_id))

            # Apply the nearest class id to all frames
            for frame in range(len(tracking_masks)):
                cls_masks_aligned[frame][tracking_masks[frame] == frame_mask_id] = nearest_cls_id

        # Save alignment info to Excel
        self.save_alignment_info(alignment_info)

        self.viewer.add_labels(cls_masks_aligned, name="Tracking masks cls", opacity=0.5)
        notifications.show_info(f'Classification masks aligned to tracking masks. Alignment information saved to {self.Bs2Code_save_path}. Label layer "Tracking masks cls" added.')
    def save_alignment_info(self, alignment_info):
        df = pd.DataFrame(alignment_info, columns=['Tracking Mask Index', 'Class'])
        self.Bs2Code_save_path = os.path.join(self.base_folder, 'Bs2Code.xlsx')
        df.to_excel(self.Bs2Code_save_path, index=False)
        print(f'Saved alignment information to {self.Bs2Code_save_path}')
        notifications.show_info(f'Saved alignment information to {self.Bs2Code_save_path}')


    def save_shifted_stack(self):
        # Save the shifted stack to a new TIF file
        folder = QFileDialog.getExistingDirectory(caption='Select Folder to Save Shifted Stack')
        if folder: # only save green channel to tif stack
            stack_g = self.viewer.layers['Stack G'].data
            tiff.imsave(os.path.join(folder, 'stack-g.tif'), stack_g)
            print(f"Shifted stack saved to {folder}")
            notifications.show_info(f"Shifted stack saved to {folder}")


    def overexpo_visualize(self):
        overexpo_thres = self.overexpo_thres_param.value
        stack_b = self.viewer.layers['Stack B'].data
        stack_g = self.viewer.layers['Stack G'].data

        overexpo_mask_b = stack_b >= overexpo_thres
        overexpo_mask_g = stack_g >= overexpo_thres

        self.viewer.add_labels(overexpo_mask_b, name="Overexposed Pixels B")
        self.viewer.add_labels(overexpo_mask_g, name="Overexposed Pixels G")

        masks = self.viewer.layers['Masks'].data

        if masks.ndim == 2:  # Assuming masks layer is single and applies to all frames
            masks = np.stack([masks] * overexpo_mask_b.shape[0], axis=0)  # Replicate masks for each frame

        masks_with_overexpo_b = np.zeros_like(masks)
        masks_with_overexpo_g = np.zeros_like(masks)

        # for i in range(masks.shape[0]): # shape[0] is the number of frames
        # use tqdm to show the progress
        for i in tqdm(range(masks.shape[0]), desc='Classifying Overexposed Pixels'):
            for j in range(1, masks[i].max() + 1):
                # show mask and overexposure mask as plot
                # plt.subplot(1, 2, 1)
                # plt.imshow(masks[i][masks[i]==j])
                # plt.title('Mask')
                # plt.subplot(1, 2, 2)
                # plt.imshow(overexpo_mask_b[i])
                # plt.title('Overexposed Pixels B')
                # plt.show()
                current_mask = masks[i]
                current_mask = np.where(current_mask == j, current_mask, 0)

                # if np.any(np.logical_and(current_mask, overexpo_mask_b[i][:])): # too slow to use logical_and for every pixels in the mask
                if np.any(current_mask[overexpo_mask_b[i][:]]):
                    if self.mask_256_checkbox.value:
                        masks_with_overexpo_b[i] += current_mask.astype(np.uint16) * j
                    else:
                        masks_with_overexpo_b[i] += current_mask.astype(np.uint8) * j
                # if np.any(np.logical_and(current_mask, overexpo_mask_g[i][:])):
                if np.any(current_mask[overexpo_mask_g[i][:]]):
                    if self.mask_256_checkbox.value:
                        masks_with_overexpo_g[i] += current_mask.astype(np.uint16) * j
                    else:
                        masks_with_overexpo_g[i] += current_mask.astype(np.uint8) * j

        # Visualization steps remain the same
        blue_cmap = Colormap(colors=[[0, 0, 1, 1]], name='blue')
        green_cmap = Colormap(colors=[[0, 1, 0, 1]], name='green')

        # self.viewer.add_labels(masks_with_overexpo_b, name="Masks with Overexposed pixels B", colormap=blue_cmap)
        # self.viewer.add_labels(masks_with_overexpo_g, name="Masks with Overexposed pixels G", colormap=green_cmap)
        self.viewer.add_labels(masks_with_overexpo_b, name="Masks with Overexposed pixels B")
        self.viewer.add_labels(masks_with_overexpo_g, name="Masks with Overexposed pixels G")
        notifications.show_info(f'Overexposed pixels visualized in layers "Overexposed pixels", overexposed masks visualized in layers "Masks with Overexposed pixels"')

    def overexpo_discard(self):
        # Discard the masks with overexposed pixels from the masks layer of green and blue channels
        masks_with_overexpo_b = self.viewer.layers['Masks with Overexposed pixels B'].data
        masks_with_overexpo_g = self.viewer.layers['Masks with Overexposed pixels G'].data
        masks = self.viewer.layers['Masks'].data

        # Create binary masks for overexposed pixels
        binary_overexpo_b = masks_with_overexpo_b > 0
        binary_overexpo_g = masks_with_overexpo_g > 0

        # Set the corresponding entries in the masks array to 0
        masks[binary_overexpo_b] = 0
        masks[binary_overexpo_g] = 0

        self.viewer.layers['Masks'].data = masks
        self.viewer.layers['Masks'].refresh()
        notifications.show_info('Overexposed masks discarded from the masks layer')


    def read_masks(self):
        # make self.base_folder to be the upper folder of the mask folder, say mask folder is E:\BC-FLIM\Track-11-test, then base folder is E:\BC-FLIM
        self.base_folder = os.path.dirname(self.mask_folder.value) # dirname can get the upper folder
        # make the calcu ratio range to be the same as the mask folder
        self.ratio_calcu_range.value = [0, len(os.listdir(self.mask_folder.value)) - 1]
        # read in all the masks in the folder and make them as a layer, if outline_checkbox is checked, transform the masks to outlines
        mask_files = [f for f in os.listdir(self.mask_folder.value) if f.endswith('.npy')]
        mask_files.sort()  # Ensure the order is consistent
        all_masks = []

        # read the first mask to get the mask type
        mask_data = np.load(os.path.join(self.mask_folder.value, mask_files[0]))
        self.mask_type = mask_data.dtype
        for file in mask_files:
            path = os.path.join(self.mask_folder.value, file)
            if self.mask_256_checkbox.value:
                masks_data = np.load(path).astype(np.uint16)
            else:
                masks_data = np.load(path).astype(np.uint8)

            all_masks.append(masks_data)

        all_masks = np.array(all_masks)  # Convert to a single array, so we can add it as a layer
        print(f'all masks shape: {all_masks.shape}')


        self.viewer.add_labels(all_masks, name="Masks")
        notifications.show_info(f'{len(mask_files)} frames read in successfully. Number of masks: {np.max(all_masks[0])}')

    def read_tif(self, name: str):
        if name == 'TIF for Tracking':
            tif_stack = tiff.imread(self.tif_input.value)
        elif name == 'Stack B':
            tif_stack = tiff.imread(self.stack_b_input.value)
        elif name == 'Stack G':
            tif_stack = tiff.imread(self.stack_g_input.value)
        self.viewer.add_image(tif_stack, name=name)
        notifications.show_info(f'{name} read in successfully')

    def save_tracking(self):
        # Open a dialog for the user to choose the folder to save the masks
        folder = QFileDialog.getExistingDirectory(caption='Select Folder to Save Masks')

        if folder:  # If a folder was chosen
            # for i, mask in enumerate(self.masks_layer.data):
            for i, mask in enumerate(self.viewer.layers['Masks'].data):
                # Save each mask to a .npy file in the chosen folder with the name 00000.npy, 00001.npy, etc.
                if self.mask_256_checkbox.value:
                    np.save(os.path.join(folder, f'{i:05d}.npy'), mask.astype(np.uint16))
                else:
                    np.save(os.path.join(folder, f'{i:05d}.npy'), mask.astype(np.uint8))
            print(f"Tracking saved to {folder}")
            notifications.show_info(f"Tweaked tracking results saved to {folder}")

    # def shift_stack(self):
    #     # shift the stack b to the right by the number of pixels specified in the shift_param
    #     shift_r = self.shift_r_param.value
    #     shift_u = -self.shift_u_param.value
    #     # stack_b = self.viewer.layers['Stack B'].data
    #     # stack_g = self.viewer.layers['Stack G'].data
    #     # now, shift the layer which user is on
    #     stack_shift = self.viewer.layers[self.viewer.active_layer.name].data
    #     # # Pad zeros to the left side along axis 2
    #     # stack_b_padded = np.pad(stack_b, ((0, 0), (0, 0), (shift_r, 0)))
    #     #
    #     # # Shift the array to the right by slicing off the leftmost elements along axis 2
    #     # stack_b_shifted = stack_b_padded[:, :, shift_r:]
    #     #
    #     # # Pad zeros to the top side along axis 1
    #     # stack_b_padded = np.pad(stack_b_shifted, ((0, 0), (shift_u, 0), (0, 0)))
    #     #
    #     # # Shift the array down by slicing off the topmost elements along axis 1
    #     # stack_b_shifted = stack_b_padded[:, shift_u:, :]
    #     # stack_b_shifted = np.roll(stack_b, shift_r, axis=2)
    #     # stack_b_shifted = np.roll(stack_b_shifted, shift_u, axis=1)
    #     # stack_g_shifted = np.roll(stack_g, shift_r, axis=2)
    #     # stack_g_shifted = np.roll(stack_g_shifted, shift_u, axis=1)
    #     # now shift the layer which user is on
    #     if stack_shift.ndim == 3:
    #         stack_shift = np.roll(stack_shift, shift_r, axis=2)
    #         stack_shift = np.roll(stack_shift, shift_u, axis=1)
    #     elif stack_shift.ndim == 2:
    #         stack_shift = np.roll(stack_shift, shift_r, axis=1)
    #         stack_shift = np.roll(stack_shift, shift_u, axis=0)
    #
    #     # self.viewer.layers['Stack B'].data = stack_b_shifted
    #     # self.viewer.layers['Stack B'].refresh()
    #     # self.viewer.layers['Stack G'].data = stack_g_shifted
    #     # self.viewer.layers['Stack G'].refresh()
    #     self.viewer.layers[self.viewer.active_layer.name].data = stack_shift
    #     self.viewer.layers[self.viewer.active_layer.name].refresh()
    #     # notifications.show_info(f'Shifted green channel by {shift_r} pixels to the right and {shift_u} pixels up')
    #     notifications.show_info(f'Shifted {self.viewer.active_layer.name} by {shift_r} pixels to the right and {shift_u} pixels up')

    def shift_stack(self):
        shift_r = self.shift_r_param.value
        shift_u = -self.shift_u_param.value

        # Get the active layer
        selected_layers = list(self.viewer.layers.selection)
        if not selected_layers:
            notifications.show_warning("No layer selected")
            return

        active_layer = selected_layers[0]  # Get the first (and usually only) selected layer
        stack_shift = active_layer.data

        if stack_shift.ndim == 3:
            stack_shift = np.roll(stack_shift, shift_r, axis=2)
            stack_shift = np.roll(stack_shift, shift_u, axis=1)
        elif stack_shift.ndim == 2:
            stack_shift = np.roll(stack_shift, shift_r, axis=1)
            stack_shift = np.roll(stack_shift, shift_u, axis=0)

        active_layer.data = stack_shift
        active_layer.refresh()

        notifications.show_info(
            f'Shifted {active_layer.name} by {shift_r} pixels to the right and {-shift_u} pixels up')
    def toggle_revise_mode(self):
        undo_key = 'u'
        # make brush size to be 1
        self.viewer.layers['Masks'].brush_size = 1
        self.masks_layer = self.viewer.layers['Masks']
        if self.revise_mode_checkbox.value:
            self.masks_layer.mouse_drag_callbacks.append(self.on_click)
            self.viewer.bind_key(undo_key, self.on_undo, overwrite=True)
            notifications.show_info('Revise Mode enabled. Press Control + Click to delete masks. Press Shift + Click to plot signal changes in the mask. Press u to undo. Do all the operations in the Masks layer.')

        else:
            self.masks_layer.mouse_drag_callbacks.remove(self.on_click)
            # self.viewer.unbind_key(undo_key, None)


    def on_click(self, layer, event):
        # self.masks_layer = layer
        if event.modifiers and event.modifiers[0] == 'Control': # if control key is pressed when clicking
            history_keep = 2 # keep certain number of history, in case memory is not enough
            position = tuple(map(int, event.position))
            label = self.masks_layer.data[position]
            # self.masks_layer.data[self.masks_layer.data == label] = 0 # set the mask to bg
            # only set the mask to bg in the current frame and following frames
            current_frame = self.viewer.dims.current_step[0]
            # if history is longer than history_keep, pop the first element
            if len(self.masks_history) > history_keep:
                self.masks_history.pop(0) # pop means remove the first element
            # save the current state of mask_layer to the history
            self.masks_history.append(self.masks_layer.data.copy())

            self.masks_layer.data[current_frame:] = np.where(self.masks_layer.data[current_frame:] == label, 0, self.masks_layer.data[current_frame:])
            # refresh the viewer
            self.masks_layer.refresh() #
            # make the label number to the deleted label
            self.masks_layer.selected_label = label  # Set the active label to the deleted label
            notifications.show_info(f'Deleted mask {label} from frame {current_frame} to the end')

        # if shift key is pressed, and also stack b and g already read in, plot the sum signal changes in frames in the stack b and g and ratio g/b in 3 plots on side bar of the clicked mask
        elif event.modifiers and event.modifiers[0] == 'Shift':
            if 'Stack B' in self.viewer.layers and 'Stack G' in self.viewer.layers:
                # get the mask label
                label = self.masks_layer.data[tuple(map(int, event.position))]
                # get the mask positions
                mask_positions = self.masks_layer.data == label
                # get the stack b and g
                stack_b = self.viewer.layers['Stack B'].data
                stack_g = self.viewer.layers['Stack G'].data
                print(f'stack b shape: {stack_b.shape}')
                print(f'stack g shape: {stack_g.shape}')
                # Ensure mask_positions is a 3D mask with the same shape as stack_b and stack_g
                if mask_positions.ndim == 2:
                    mask_positions = np.repeat(mask_positions[np.newaxis, :, :], stack_b.shape[0], axis=0)
                print(f'mask positions shape: {mask_positions.shape}')
                # sum all the signals in the mask in stack b and g, in one plot, there's only one line, time point is the number of frames
                print(f'stack b[mask_positions] shape: {stack_b[mask_positions].shape}')
                sum_b = np.zeros(stack_b.shape[0])
                sum_g = np.zeros(stack_g.shape[0])
                for i in range(stack_b.shape[0]):
                    sum_b[i] = np.sum(stack_b[i][mask_positions[i]])
                    sum_g[i] = np.sum(stack_g[i][mask_positions[i]])
                # ratio g/b in another plot
                ratio_gb = sum_g / sum_b
                # plot the sum signal changes in frames in the stack b and g and ratio g/b in 3 plots on side bar of the clicked mask
                self.plot_widget.plot_signal(sum_b, sum_g, ratio_gb)
                # make the label number to the clicked label
                self.masks_layer.selected_label = label
                notifications.show_info(f'Plotted signal changes in mask {label} in the bottom plot widget')


    def on_undo(self, event):
        print('undo called')
        if self.masks_history:
            print('undo')
            notifications.show_info('Undo')
            # Revert to the previous state
            self.masks_layer.data = self.masks_history.pop()
            self.masks_layer.refresh()

    def apply_to_following_frames(self):
        self.masks_layer = self.viewer.layers['Masks']
        # print(f'current mask shape: {self.masks_layer.data.shape}')

        # Get the current mask label
        current_mask_label = self.masks_layer.selected_label # get the selected label
        # current_mask_label = np.unique(self.masks_layer.data[self.viewer.dims.current_step[0]])[1]
        print(f'current mask label: {current_mask_label}')

        current_frame = self.viewer.dims.current_step[0]
        # print(f'current frame: {current_frame}')

        # Get positions where current mask label is present in the current frame
        mask_positions = np.where(self.masks_layer.data[current_frame] == current_mask_label)
        # print(f'mask positions shape: {mask_positions[0].shape}')

        # Apply this mask label to the same positions in all following frames
        num_frames = self.masks_layer.data.shape[0]
        for frame in range(current_frame + 1, num_frames):
            # Set the mask label at the identified positions in the following frames
            self.masks_layer.data[frame][mask_positions] = current_mask_label

        # Refresh the mask layer to update the viewer
        self.masks_layer.refresh()
        notifications.show_info(f'Applied mask label {current_mask_label} to following frames ({current_frame + 1} to {num_frames - 1})')






# import torch

# TAM_path = r'E:\Software\TrackAnything\Track-Anything-master'
# if TAM_path not in sys.path:
#     sys.path.append(TAM_path)
# TAM_model_path = os.path.join(TAM_path, 'tracker', 'model')
# if TAM_model_path not in sys.path:
#     sys.path.append(TAM_model_path)
# TAM_path = r'D:\PKU_STUDY\DeepLearining\BC-FLIM\python_code\BC-FLIM-S\BC-FLIM-Spectra\src\flim_s_gen'
# if TAM_path not in sys.path:
#     sys.path.append(TAM_path)
# from track_anything import TrackingAnything, parse_augment
#
# class CellTrackingWidget(QWidget):
#     def __init__(self, napari_viewer):
#         super().__init__()
#         self.viewer = napari_viewer
#         self.layout = QVBoxLayout()
#         self.setLayout(self.layout)
#
#         # Load TIFF stack button
#         self.load_tiff_button = QPushButton("Load TIFF Stack")
#         self.load_tiff_button.clicked.connect(self.load_tiff_stack)
#         self.layout.addWidget(self.load_tiff_button)
#
#         # Load Mask button
#         self.load_mask_button = QPushButton("Load Mask")
#         self.load_mask_button.clicked.connect(self.load_mask)
#         self.layout.addWidget(self.load_mask_button)
#
#         # Cell distance input
#         self.cell_dist_label = QLabel("Cell Distance")
#         self.layout.addWidget(self.cell_dist_label)
#         self.cell_dist_input = QLineEdit("25")
#         self.layout.addWidget(self.cell_dist_input)
#
#         # Padding input
#         self.padding_label = QLabel("Padding")
#         self.layout.addWidget(self.padding_label)
#         self.padding_input = QLineEdit("45")
#         self.layout.addWidget(self.padding_input)
#
#         # add a check box for only track the current mask
#         self.current_mask_checkbox = QCheckBox("Only Track Current Mask")
#         self.layout.addWidget(self.current_mask_checkbox)
#
#         # Start Tracking button
#         self.track_button = QPushButton("Start Tracking")
#         self.track_button.clicked.connect(self.start_tracking)
#         self.layout.addWidget(self.track_button)
#
#         # Initialize variables
#         self.tiff_stack = None
#         self.mask = None
#         self.tracking_model = self.initialize_tracking_model()
#
#     def load_tiff_stack(self):
#         file_path, _ = QFileDialog.getOpenFileName(self, "Select TIFF Stack", "", "TIFF files (*.tif *.tiff)")
#         if file_path:
#             self.tiff_stack = tiff.imread(file_path)
#             self.viewer.add_image(self.tiff_stack, name="TIFF Stack")
#             # initialize an empty mask layer for tracking results
#             self.track_frames = np.zeros_like(self.tiff_stack, dtype=np.uint8)
#             self.viewer.add_labels(self.track_frames, name="Tracking frames")
#
#     def load_mask(self):
#         file_path, _ = QFileDialog.getOpenFileName(self, "Select Mask File", "", "NumPy files (*.npy)")
#         if file_path:
#             self.mask = np.load(file_path, allow_pickle=True).item()['masks'].astype(np.uint8)
#             self.viewer.add_labels(self.mask, name="Mask")
#
#     def initialize_tracking_model(self):
#         SAM_checkpoint_dict = {
#             'vit_h': "sam_vit_h_4b8939.pth",
#             'vit_l': "sam_vit_l_0b3195.pth",
#             "vit_b": "sam_vit_b_01ec64.pth"
#         }
#         SAM_checkpoint_url_dict = {
#             'vit_h': "https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth",
#             'vit_l': "https://dl.fbaipublicfiles.com/segment_anything/sam_vit_l_0b3195.pth",
#             'vit_b': "https://dl.fbaipublicfiles.com/segment_anything/sam_vit_b_01ec64.pth"
#         }
#         sam_checkpoint = SAM_checkpoint_dict['vit_h']
#         sam_checkpoint_url = SAM_checkpoint_url_dict['vit_h']
#         xmem_checkpoint = "XMem-s012.pth"
#         xmem_checkpoint_url = "https://github.com/hkchengrex/XMem/releases/download/v1.0/XMem-s012.pth"
#         e2fgvi_checkpoint = "E2FGVI-HQ-CVPR22.pth"
#         e2fgvi_checkpoint_id = "10wGdKSUOie0XmCr8SQ2A2FeDe-mfn5w3"
#         folder = "./checkpoints"
#
#         SAM_checkpoint = self.download_checkpoint(sam_checkpoint_url, folder, sam_checkpoint)
#         xmem_checkpoint = self.download_checkpoint(xmem_checkpoint_url, folder, xmem_checkpoint)
#         e2fgvi_checkpoint = self.download_checkpoint_from_google_drive(e2fgvi_checkpoint_id, folder, e2fgvi_checkpoint)
#
#         args = parse_augment()
#         args.port = 12213
#         args.device = "cuda:0"
#         args.mask_save = True
#
#         model = TrackingAnything(SAM_checkpoint, xmem_checkpoint, e2fgvi_checkpoint, args)
#         return model
#
#     def download_checkpoint(self, url, folder, filename):
#         os.makedirs(folder, exist_ok=True)
#         filepath = os.path.join(folder, filename)
#         if not os.path.exists(filepath):
#             # Implement download logic here
#             pass
#         return filepath
#
#     def download_checkpoint_from_google_drive(self, file_id, folder, filename):
#         os.makedirs(folder, exist_ok=True)
#         filepath = os.path.join(folder, filename)
#         if not os.path.exists(filepath):
#             # Implement Google Drive download logic here
#             pass
#         return filepath
#
#     def start_tracking(self):
#         if self.tiff_stack is None or self.mask is None:
#             return
#
#         cell_dist = int(self.cell_dist_input.text())
#         padding = int(self.padding_input.text())
#
#         # Update track_masks function to call it
#         results = self.track_masks(self.tiff_stack, self.mask, cell_dist, padding)
#         self.viewer.layers['Tracking frames'].data = results
#         self.viewer.layers['Tracking frames'].refresh()
#         # self.track_masks(self.tiff_stack, self.mask, cell_dist, padding)
#         # Display results in Napari
#         # for i, mask in enumerate(results):
#         #     self.viewer.add_labels(mask, name=f"Tracked Mask {i + 1}")
#
#     def track_masks(self, tiff_stack, mask, cell_dist=25, padding=45):
#         log_scale = 0.005
#         log_constant = 65535 / np.log(1 + 65535 * log_scale)
#         colormap = plt.get_cmap('viridis')
#
#         # Convert TIFF stack to RGB using logarithmic scaling and color mapping
#         tiff_stack_rgb = np.zeros((tiff_stack.shape[0], tiff_stack.shape[1], tiff_stack.shape[2], 3), dtype=np.uint8)
#         for i, img in enumerate(tiff_stack):
#             img = img.astype(np.float32)
#             img = img - np.min(img)
#             img = np.log(1 + img * log_scale) * log_constant
#             img = cv2.normalize(img, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
#             tiff_rgb = colormap(img)[:, :, :3]
#             tiff_rgb = (tiff_rgb * 255).astype(np.uint8)
#             tiff_stack_rgb[i] = tiff_rgb
#
#         # Initialize the combined mask
#         combined_mask = np.zeros_like(tiff_stack[1:], dtype=np.uint8)
#
#         if self.current_mask_checkbox.isChecked():
#             # get the current mask index in the mask layer
#             current_mask_index = self.viewer.layers['Mask'].selected_label
#             mask_numbers = [current_mask_index]
#             mask_contours = {current_mask_index: self.find_contours(mask)}
#             batches = self.find_nearest_masks(mask_contours, cell_dist)
#
#
#
#         else:
#             mask_numbers = np.unique(mask)
#             mask_numbers = mask_numbers[mask_numbers != 0]
#             # mask_contours = {i: self.find_contours(mask == i) for i in mask_numbers}
#             mask
#             batches = self.find_nearest_masks(mask_contours, cell_dist)
#
#         for batch in batches:
#             batch_mask = np.zeros_like(mask, dtype=np.uint8)
#             for mask_number in batch:
#                 batch_mask += (mask == mask_number).astype(np.uint8) * mask_number
#
#             x, y, w, h = cv2.boundingRect(batch_mask)
#             pad_x1 = max(x - padding, 0)
#             pad_y1 = max(y - padding, 0)
#             pad_x2 = min(x + w + padding, mask.shape[1])
#             pad_y2 = min(y + h + padding, mask.shape[0])
#
#             cropped_images = [img[pad_y1:pad_y2, pad_x1:pad_x2] for img in tiff_stack_rgb[1:]]
#             template_mask = batch_mask[pad_y1:pad_y2, pad_x1:pad_x2]
#
#             masks, _, _ = self.tracking_model.generator(cropped_images, template_mask)
#             self.tracking_model.xmem.clear_memory()
#             combined_mask[:, pad_y1:pad_y2, pad_x1:pad_x2] = np.maximum(combined_mask[:, pad_y1:pad_y2, pad_x1:pad_x2],
#                                                                         masks)
#
#             # Display the tracked masks frame by frame
#             # for frame in combined_mask:
#             #     # self.viewer.add_labels(frame, name="Tracked Frame", color="blue")
#             #     self.viewer.add_labels(frame, name="Tracked Frame", opacity=0.5)
#         # add the results to the track frames layer
#         # self.viewer.layers['Tracking frames'].data = combined_mask
#         # self.viewer.layers['Tracking frames'].refresh()
#         return combined_mask
#
#     def find_contours(self, mask):
#         mask_uint8 = mask.astype(np.uint8)
#         contours, _ = cv2.findContours(mask_uint8, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
#         contours = [np.squeeze(contour, axis=1) for contour in contours]
#         for i, contour in enumerate(contours):
#             if not np.array_equal(contour[0], contour[-1]):
#                 contours[i] = np.vstack([contour, contour[0]])
#         contours = np.array(contours, dtype=np.uint16)
#         return contours
#
#     def find_nearest_masks(self, mask_contours, cell_dist):
#         mask_numbers = list(mask_contours.keys())
#         mask_numbers = np.array(mask_numbers, dtype=np.uint8)
#         batches = []
#         processed = set()
#
#         for index in mask_numbers:
#             if index in processed:
#                 continue
#             current_batch = {index}
#             stack = [index]
#             while stack:
#                 current_index = stack.pop()
#                 for other_index in mask_numbers:
#                     if other_index not in processed and other_index != current_index:
#                         if len(mask_contours[current_index]) > 0 and len(mask_contours[other_index]) > 0:
#                             min_dist = np.inf
#                             for contour1 in mask_contours[current_index]:
#                                 for contour2 in mask_contours[other_index]:
#                                     dist = cdist(contour1, contour2, 'euclidean').min()
#                                     if dist < min_dist:
#                                         min_dist = dist
#                             if min_dist < cell_dist:
#                                 if other_index not in current_batch:
#                                     stack.append(other_index)
#                                     current_batch.add(other_index)
#                                     processed.add(other_index)
#             batches.append(list(current_batch))
#
#         return batches

# class CutieZiTrackWidget(QWidget):













